<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Comprehensive LEO Tracker</title>

    <!-- Three.js Library for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Satellite.js Library for TLE (Two-Line Element) propagation to calculate satellite positions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.1.4/satellite.min.js"></script>

    <style>
        /* Basic reset and full-page layout */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars */
            height: 100%; /* Full height */
            font-family: 'Arial', sans-serif;
            background: #000; /* Dark background for space theme */
        }
        
        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        /* Styles for the control panel */
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100; /* Ensure controls are above the 3D scene */
            background: rgba(0, 0, 0, 0.8); /* Semi-transparent black background */
            padding: 20px;
            border-radius: 10px;
            color: white;
            min-width: 250px;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3); /* Greenish glow */
        }
        
        #controls h3 {
            margin: 0 0 15px 0;
            color: #00ff88; /* Accent color */
            text-shadow: 0 0 5px #00ff88;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }
        
        /* Button styles */
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* Gradient background */
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px 5px 5px 0;
            font-size: 12px;
            transition: all 0.3s ease; /* Smooth transitions for hover effects */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        button:hover {
            transform: translateY(-2px); /* Slight lift effect */
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); /* Enhanced shadow on hover */
        }
        
        button.active {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%); /* Active button accent color */
            box-shadow: 0 0 10px #00ff88;
        }
        
        /* Styles for the live statistics panel */
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
            min-width: 200px;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }
        
        #stats h4 {
            margin: 0 0 10px 0;
            color: #00ff88;
            text-shadow: 0 0 5px #00ff88;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }

        /* Styles for the legend */
        #legend {
            position: absolute;
            bottom: 320px; /* Position above satellite details */
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }

        #legend h4 {
            margin: 0 0 10px 0;
            color: #00ff88;
            text-shadow: 0 0 5px #00ff88;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        /* Set colors for legend dots */
        .legend-dot.starlink { background: #00ff88; } /* Green */
        .legend-dot.other-leo { background: #6699ff; } /* Blue */
        .legend-dot.debris { background: #ffaa00; } /* Orange */
        .legend-dot.inactive { background: #ff4444; } /* Red */


    /* Styles for the satellite list panel */
    #satelliteList {
        position: absolute;
        left: 20px;
        bottom: 50px;
        width: 280px;
        max-height: 400px; /* Limit height for scrollability */
        background: rgba(0, 0, 0, 0.9);
        border-radius: 10px;
        color: white;
        font-size: 11px;
        z-index: 100;
        overflow-y: auto; /* Enable scrolling for long lists */
        display: none; /* Hidden by default, toggled by button */
        box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
    }

    #satelliteList h4 {
        margin: 0;
        padding: 15px;
        color: #00ff88;
        border-bottom: 1px solid #333;
        text-shadow: 0 0 5px #00ff88;
        position: sticky; /* Keep header visible when scrolling */
        top: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 101;
    }

    .satellite-item {
        padding: 8px 15px;
        border-bottom: 1px solid #222;
        cursor: pointer;
        transition: background 0.2s;
        display: flex;
        align-items: center;
    }

    .satellite-item:last-child {
        border-bottom: none; /* No border for the last item */
    }

    .satellite-item:hover {
        background: rgba(255, 255, 255, 0.1);
    }

    .satellite-item.selected {
        background: rgba(0, 255, 136, 0.2); /* Highlight selected item */
        border-left: 3px solid #00ff88;
        padding-left: 12px;
    }

    .satellite-status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 8px;
        flex-shrink: 0;
    }
    /* Set colors for satellite status dots */
    .satellite-status-dot.starlink { background: #00ff88; }
    .satellite-status-dot.other-leo { background: #6699ff; }
    .satellite-status-dot.debris { background: #ffaa00; }
    .satellite-status-dot.inactive { background: #ff4444; }


    /* Styles for the satellite details panel */
    #satelliteDetails {
        position: absolute;
        right: 20px;
        bottom: 20px;
        width: 250px;
        background: rgba(0, 0, 0, 0.9);
        border-radius: 10px;
        color: white;
        font-size: 12px;
        z-index: 100;
        display: none; /* Hidden by default, shown on selection */
        padding: 15px;
        box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
    }

    #satelliteDetails h4 {
        margin: 0 0 10px 0;
        color: #00ff88;
        text-shadow: 0 0 5px #00ff88;
    }

    .detail-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        padding: 4px 0;
        border-bottom: 1px solid #333;
    }

    .detail-item:last-child {
        border-bottom: none;
    }

    .detail-value {
        color: #00ff88;
        font-weight: bold;
    }
    
    /* Styles for the loading overlay */
    #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 18px;
        z-index: 1000; /* Ensure it's on top */
        text-align: center;
        background: rgba(0, 0, 0, 0.7);
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 0 25px rgba(0, 255, 136, 0.5);
    }
    
    .spinner {
        border: 3px solid #333;
        border-top: 3px solid #00ff88; /* Green accent for spinner */
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite; /* Spinning animation */
        margin: 0 auto 10px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Styles for the slider and its label */
    input[type="range"] {
        width: 100%;
        margin-top: 10px;
        -webkit-appearance: none; /* Remove default styling */
        height: 8px;
        background: #444; /* Darker track for better visibility */
        border-radius: 5px;
        outline: none;
        opacity: 0.8;
        transition: opacity .2s;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #00ff88;
        cursor: pointer;
        box-shadow: 0 0 5px #00ff88;
    }

    input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #00ff88;
        cursor: pointer;
        box-shadow: 0 0 5px #00ff88;
    }

    #yearDisplay, #percentageDisplay {
        margin-top: 5px;
        font-size: 14px;
        color: #00ff88;
        text-align: center;
        font-weight: bold;
    }
</style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div class="spinner"></div>
            Loading Earth and Satellite data...
        </div>
        
        <div id="controls">
            <h3>🛰️ LEO Tracker</h3>
            
            <div class="control-group">
                <button id="toggleStarlink" class="active">Show Starlink</button>
                <button id="toggleOtherLeo">Show Other LEO</button> 
                <button id="toggleDebris">Show Debris</button><br>
                <button id="toggleInactive">Show Inactive (Simulated)</button>
                <button id="toggleDensityMap">Show Density Map</button>
            </div>
            
            <div class="control-group">
                <button id="toggleOrbits">Show Orbits</button>
                <button id="toggleTrails">Show Trails</button>
                <button id="toggleLabels">Show List</button>
            </div>
            
            <div class="control-group">
                <label>Satellite Size:</label>
                <button onclick="setSatelliteSize(0.5, this)">Small</button>
                <button onclick="setSatelliteSize(1, this)" class="active">Medium</button>
                <button onclick="setSatelliteSize(2, this)">Large</button>
            </div>
            
            <div class="control-group">
                <button onclick="focusOnConstellation()">Focus Constellation</button>
                <button onclick="resetView()">Reset View</button>
            </div>

            <div class="control-group">
                <label for="timelineSlider">Deployment Timeline:</label>
                <input type="range" id="timelineSlider" min="2019" max="2025" value="2025">
                <div id="yearDisplay">2025</div>
            </div>

            <!-- New Percentage Slider -->
            <div class="control-group">
                <label for="percentageSlider">Display Percentage:</label>
                <input type="range" id="percentageSlider" min="1" max="100" value="25">
                <div id="percentageDisplay">25%</div>
            </div>
        </div>
        
        <div id="stats">
            <h4>Live Stats</h4>
            <div class="stat-item">
                <span>Total Displayed:</span>
                <span class="stat-value" id="totalDisplayedSats">0</span>
            </div>
            <div class="stat-item">
                <span>Starlink Displayed:</span>
                <span class="stat-value" id="starlinkDisplayedSats">0</span>
            </div>
            <div class="stat-item">
                <span>Other LEO Displayed:</span>
                <span class="stat-value" id="otherLeoDisplayedSats">0</span>
            </div>
            <div class="stat-item">
                <span>Debris Displayed:</span>
                <span class="stat-value" id="debrisDisplayedSats">0</span>
            </div>
            <div class="stat-item">
                <span>Inactive Displayed:</span>
                <span class="stat-value" id="inactiveDisplayedSats">0</span>
            </div>
            <div class="stat-item">
                <span>Avg Altitude:</span>
                <span class="stat-value" id="avgAlt">0 km</span>
            </div>
            <div class="stat-item">
                <span>Coverage (Sim.):</span>
                <span class="stat-value" id="coverage">0%</span>
            </div>
            <div class="stat-item">
                <span>Update Rate:</span>
                <span class="stat-value">Real-time</span>
            </div>
        </div>

        <div id="satelliteList">
            <h4>🛰️ Satellite List</h4>
            <div id="satelliteListContent"></div>
        </div>

        <div id="satelliteDetails">
            <h4>📡 Satellite Details</h4>
            <div id="satelliteDetailsContent">
                <p>Click on a satellite to view details</p>
            </div>
        </div>

        <div id="legend">
            <h4>Legend</h4>
            <div class="legend-item">
                <div class="legend-dot starlink"></div>
                <span>Starlink</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot other-leo"></div>
                <span>Other LEO (OneWeb, Iridium)</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot debris"></div>
                <span>Debris</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot inactive"></div>
                <span>Inactive (Simulated)</span>
            </div>
        </div>
    </div>

    <!-- Custom Message Box for non-alert notifications -->
    <div id="messageBox">
        <p id="messageBoxText"></p>
        <button onclick="hideMessageBox()">OK</button>
    </div>

    <script>
        let scene, camera, renderer, earth, earthGroup;
        let allSatellites3D = []; // Stores ALL Three.js satellite objects for currently rendered view
        let orbitPaths = []; // Stores Three.js orbit line objects
        let satelliteTrails = []; // Stores Three.js trail objects
        let raycaster, mouse;
        let selectedSatellite = null; // References the 3D object of the selected satellite
        
        // Visibility Toggles
        let starlinkVisible = true;
        let otherLeoVisible = false;
        let debrisVisible = false;
        let inactiveVisible = false;
        let densityMapVisible = false; // New toggle for heatmap
        let orbitsVisible = false;
        let trailsVisible = false;
        let labelsVisible = false; 

        let satelliteSize = 1; // Default medium size for satellites
        let isAnimating = false; // Flag to control animation loop start/stop

        // Constants for visualization scaling and detail
        const EARTH_RADIUS = 100; // Radius of Earth in Three.js units
        const SCALE_FACTOR = 0.1; // Scales real-world altitude (km) to Three.js units
        const TRAIL_LENGTH = 50; // Number of points in the satellite trail
        
        // Colors for different satellite types
        const STARLINK_COLOR = 0x00ff88; // Green
        const OTHER_LEO_COLOR = 0x6699ff; // Blue
        const DEBRIS_COLOR = 0xffaa00;   // Orange
        const INACTIVE_COLOR = 0xff4444; // Red

        // Define the horizontal offset for the globe 
        const GLOBE_OFFSET_X = 80;

        // Arrays to store ALL fetched and parsed satellite data, categorized by type
        let allStarlinkData = []; 
        let allOtherLeoData = []; // Combined OneWeb and Iridium
        let allDebrisData = [];   // Combined Fengyun and Cosmos debris
        let allInactiveData = []; // Simulated Inactive satellites (generated)

        // Array to store currently displayed satellites (filtered by timeline AND percentage AND visibility)
        let displayedSatellitesData = []; // Stores the DATA objects, not the 3D objects

        // Variable for controlling the display percentage of real satellites
        // Default to 0.25 (25%) for a less CPU-intensive initial load
        let currentDisplayPercentage = 0.25; 

        // For Density Map
        let densityMapMesh = null;
        const DENSITY_GRID_RESOLUTION = 10; // Number of divisions for latitude/longitude
        const DENSITY_ALTITUDE_LAYERS = 3; // Number of altitude layers
        const LEO_ALT_MIN = 160; // LEO min alt in km
        const LEO_ALT_MAX = 2000; // LEO max alt in km

        /**
         * Displays a custom message box to the user (replaces alert()).
         * @param {string} message - The message to display.
         */
        function showMessageBox(message) {
            const messageBox = document.getElementById('messageBox');
            const messageBoxText = document.getElementById('messageBoxText');
            messageBoxText.textContent = message;
            messageBox.style.display = 'block';
        }

        /**
         * Hides the custom message box.
         */
        function hideMessageBox() {
            document.getElementById('messageBox').style.display = 'none';
        }

        /**
         * Fetches TLE data for a specific group from Celestrak.
         * @param {string} groupName - The name of the TLE group (e.g., 'starlink').
         * @returns {Promise<string|null>} The TLE data as a string, or null if fetching fails.
         */
        async function fetchTLEGroup(groupName) {
            try {
                const response = await fetch(`https://celestrak.org/NORAD/elements/gp.php?GROUP=${groupName}&FORMAT=tle`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for group ${groupName}`);
                }
                const tleText = await response.text();
                return tleText;
            } catch (error) {
                console.error(`Failed to fetch TLEs for ${groupName}:`, error);
                return null;
            }
        }

        /**
         * Parses raw TLE text into a structured array of satellite objects,
         * including extracting the launch year and assigning a type.
         * @param {string} tleText - The TLE data as a string (multi-line).
         * @param {string} type - The type of satellite ('starlink', 'other-leo', 'debris').
         * @returns {Array<Object>} An array of objects, each representing a satellite.
         */
        function parseTLEs(tleText, type) {
            const lines = tleText.trim().split('\n');
            const satellites = [];
            for (let i = 0; i < lines.length; i += 3) {
                if (i + 2 >= lines.length) continue; // Ensure complete TLE block
                const name = lines[i].trim();
                const tle1 = lines[i + 1];
                const tle2 = lines[i + 2];

                let launchYear = null;
                // Attempt to extract launch year for real TLEs
                if (tle1 && tle1.length >= 11) {
                    const launchYearStr = tle1.substring(9, 11);
                    if (!isNaN(launchYearStr)) { // Check if it's a valid number
                        let twoDigitYear = parseInt(launchYearStr, 10);
                        launchYear = (twoDigitYear < 57) ? (2000 + twoDigitYear) : (1900 + twoDigitYear);
                    }
                }
                // Assign a unique id for each satellite
                let idPrefix = '';
                if (type === 'starlink') idPrefix = 'STARLINK-';
                else if (type === 'other-leo') idPrefix = 'OTHERLEO-';
                else if (type === 'debris') idPrefix = 'DEBRIS-';
                const satrec = satellite.twoline2satrec(tle1, tle2);
                // Extract inclination from TLE line 2 (columns 8-16)
                let inclination = 0;
                if (tle2 && tle2.length >= 16) {
                    inclination = parseFloat(tle2.substring(8, 16));
                }
                // Get initial position
                let latitude = 0, longitude = 0, altitude = 0;
                if (satrec) {
                    const pos = getSatPosition(satrec, new Date());
                    if (pos) {
                        latitude = pos.latitude;
                        longitude = pos.longitude;
                        altitude = pos.altitude;
                    }
                }
                satellites.push({ 
                    id: idPrefix + i, // Unique id for each satellite
                    name, 
                    tle1, 
                    tle2, 
                    launchYear, 
                    type, 
                    satrec: satrec, // Store satrec for propagation
                    status: 'active', // Default status, can be refined for actual inactive later
                    inclination: inclination,
                    velocity: 7.5, // Approximate LEO velocity in km/s
                    latitude: latitude,
                    longitude: longitude,
                    altitude: altitude
                });
            }
            return satellites;
        }

        /**
         * Loads and processes TLE data for all satellite categories.
         * Stores data in respective `all...Data` arrays.
         */
        async function loadAllSatelliteData() {
            document.getElementById('loading').style.display = 'block'; 

            // Fetch Starlink
            const starlinkTleText = await fetchTLEGroup('starlink');
            if (starlinkTleText) {
                allStarlinkData = parseTLEs(starlinkTleText, 'starlink');
            }

            // Fetch Other LEO (OneWeb, Iridium)
            const onewebTleText = await fetchTLEGroup('oneweb');
            if (onewebTleText) {
                allOtherLeoData.push(...parseTLEs(onewebTleText, 'other-leo'));
            }
            const iridiumTleText = await fetchTLEGroup('iridium');
            if (iridiumTleText) {
                allOtherLeoData.push(...parseTLEs(iridiumTleText, 'other-leo'));
            }

            // Fetch Debris (Fengyun 1C, Cosmos 2251)
            const fy1cDebrisTleText = await fetchTLEGroup('fengyun_1c_debris');
            if (fy1cDebrisTleText) {
                allDebrisData.push(...parseTLEs(fy1cDebrisTleText, 'debris'));
            }
            const c2251DebrisTleText = await fetchTLEGroup('cosmos_2251_debris');
            if (c2251DebrisTleText) {
                allDebrisData.push(...parseTLEs(c2251DebrisTleText, 'debris'));
            }
            
            // Generate Simulated Inactive Satellites
            generateSimulatedInactiveSatellites(200); // Generate 200 simulated inactive
            
            initSceneElements(); // Initialize scene after data is loaded
            
            document.getElementById('loading').style.display = 'none'; 
            isAnimating = true; 
            animate(); 
        }

        /**
         * Generates a fixed number of simulated "Inactive" satellites.
         * @param {number} count - The number of inactive satellites to simulate.
         */
        function generateSimulatedInactiveSatellites(count) {
            allInactiveData = [];
            const inactiveMinAlt = 200; // Lower altitude for inactive
            const inactiveMaxAlt = 600; // Still in LEO but potentially decaying

            for (let i = 0; i < count; i++) {
                const lat = (Math.random() * 180) - 90;
                const lon = (Math.random() * 360) - 180;
                const alt = Math.random() * (inactiveMaxAlt - inactiveMinAlt) + inactiveMinAlt;

                allInactiveData.push({
                    id: `INACTIVE-${i}`,
                    name: `Inactive Sat ${i + 1}`,
                    latitude: lat,
                    longitude: lon,
                    altitude: alt,
                    velocity: 7.0, // Fixed velocity for simulation
                    status: 'inactive',
                    inclination: Math.random() * 90,
                    type: 'inactive',
                    tle1: null, // No TLE for simulated
                    tle2: null,
                    satrec: null // No satrec for simulated
                });
            }
        }

        /**
         * Calculates the geodetic position (latitude, longitude, altitude) of a satellite
         * for a given date using the satellite.js library (SGP4 propagation).
         * @param {object} satrec - Satellite record object from satellite.js.
         * @param {Date} date - The specific date and time for position calculation.
         * @returns {object|null} An object with latitude (degrees), longitude (degrees),
         * and altitude (km), or null if propagation fails.
         */
        function getSatPosition(satrec, date) {
            if (!satrec) return null; // Handle simulated satellites with no satrec
            const positionAndVelocity = satellite.propagate(satrec, date);
            const positionEci = positionAndVelocity.position;
            
            if (!positionEci) {
                return null; 
            }

            const gmst = satellite.gstime(date); 
            const positionGd = satellite.eciToGeodetic(positionEci, gmst); 
            
            return {
                latitude: satellite.degreesLat(positionGd.latitude), 
                longitude: satellite.degreesLong(positionGd.longitude), 
                altitude: positionGd.height 
            };
        }

        /**
         * Initializes the Three.js scene, camera, renderer, and adds a starry background.
         */
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000008); 
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(0, 0, 300); 
            camera.lookAt(0, 0, 0); 
            
            renderer = new THREE.WebGLRenderer({ antialias: true }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.getElementById('container').appendChild(renderer.domElement);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2(); 
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3); 
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 1); 
            sunLight.position.set(500, 200, 500); 
            sunLight.castShadow = true; 
            sunLight.shadow.mapSize.width = 2048; 
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            
            createStarField();
            setupControls();

            loadAllSatelliteData(); // Load all data initially
        }

        /**
         * Creates a background star field using Three.js Points.
         */
        function createStarField() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 }); 
            
            const starsVertices = [];
            for (let i = 0; i < 1000; i++) {
                const radius = 2000; 
                const x = (Math.random() - 0.5) * radius * 2;
                const y = (Math.random() - 0.5) * radius * 2;
                const z = (Math.random() - 0.5) * radius * 2;
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        /**
         * Initializes 3D objects related to Earth and sets up sliders.
         */
        function initSceneElements() {
            createEarth();
            
            if (earthGroup) {
                earthGroup.position.x = GLOBE_OFFSET_X; 
            }

            setupTimelineSlider(); 
            setupPercentageSlider(); 
            createDensityMap(); // Create the density map grid once
            // Initial display update based on default slider values and toggles
            updateDisplayFromControls(); 
        }
        
        /**
         * Creates the Earth 3D model with a texture map and an atmospheric glow.
         */
        function createEarth() {
            earthGroup = new THREE.Group(); 
            const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64); 
            const earthTextureUrl = 'earth.jpg'; 
            
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(earthTextureUrl, function(earthTexture) {
                const earthMaterial = new THREE.MeshPhongMaterial({
                    map: earthTexture, 
                    shininess: 30, 
                    specular: 0x222222 
                });

                earth = new THREE.Mesh(earthGeometry, earthMaterial);
                earth.receiveShadow = true; 
                earthGroup.add(earth); 

                const atmosphereGeometry = new THREE.SphereGeometry(EARTH_RADIUS * 1.05, 32, 32); 
                const atmosphereMaterial = new THREE.ShaderMaterial({
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vNormal;
                        void main() {
                            float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                            gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity; 
                        }
                    `,
                    blending: THREE.AdditiveBlending, 
                    side: THREE.BackSide, 
                    transparent: true 
                });
                const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                earthGroup.add(atmosphere); 

                scene.add(earthGroup); 
            }, undefined, function(err) {
                console.error("Failed to load Earth texture:", err);
                showMessageBox("Error loading Earth texture. Please ensure 'earth.jpg' is in the same directory.");
            });
        }

        /**
         * Clears all existing satellite meshes, orbits, and trails from the scene.
         */
        function clearExistingVizElements() {
            allSatellites3D.forEach(obj => {
                if (obj.group.parent) obj.group.parent.remove(obj.group);
                obj.dot.geometry.dispose();
                obj.dot.material.dispose();
                obj.glow.geometry.dispose();
                obj.glow.material.dispose();
            });
            allSatellites3D = [];

            orbitPaths.forEach(obj => {
                if (obj.parent) obj.parent.remove(obj);
                if (obj.children[0]) {
                    obj.children[0].geometry.dispose();
                    obj.children[0].material.dispose();
                }
            });
            orbitPaths = [];

            satelliteTrails.forEach(obj => {
                if (obj.group.parent) obj.group.parent.remove(obj.group);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.line && obj.line.material) obj.line.material.dispose();
            });
            satelliteTrails = [];
        }
        
        /**
         * Updates the displayed satellites, orbits, and trails based on current control states.
         */
        function updateDisplayFromControls() {
            clearExistingVizElements(); 

            const selectedYear = parseInt(document.getElementById('timelineSlider').value);
            const displayPercentage = parseFloat(document.getElementById('percentageSlider').value) / 100;

            displayedSatellitesData = []; // Reset the data array for currently displayed satellites

            if (starlinkVisible) {
                // Filter Starlinks by year and percentage
                const filteredStarlinks = allStarlinkData.filter(sat => 
                    sat.launchYear <= selectedYear && Math.random() < displayPercentage
                );
                displayedSatellitesData.push(...filteredStarlinks);
            }

            if (otherLeoVisible) {
                // Filter Other LEO by year and percentage
                const filteredOtherLeo = allOtherLeoData.filter(sat => 
                    sat.launchYear <= selectedYear && Math.random() < displayPercentage
                );
                displayedSatellitesData.push(...filteredOtherLeo);
            }

            if (debrisVisible) {
                // Filter Debris by year and percentage
                const filteredDebris = allDebrisData.filter(sat => 
                    sat.launchYear <= selectedYear && Math.random() < displayPercentage
                );
                displayedSatellitesData.push(...filteredDebris);
            }

            if (inactiveVisible) {
                // Inactive satellites are always shown 100% of their simulated count when toggled on
                displayedSatellitesData.push(...allInactiveData);
            }

            // Create 3D objects for all displayed satellites
            displayedSatellitesData.forEach((satData, index) => {
                let color;
                if (satData.type === 'starlink') color = STARLINK_COLOR;
                else if (satData.type === 'other-leo') color = OTHER_LEO_COLOR;
                else if (satData.type === 'debris') color = DEBRIS_COLOR;
                else if (satData.type === 'inactive') color = INACTIVE_COLOR;

                const satellite = createSatellite(satData, index, color);
                allSatellites3D.push(satellite); // Add to combined 3D objects array
                earthGroup.add(satellite.group); 
                
                if (trailsVisible) {
                    const trail = createSatelliteTrail(satData, color);
                    satelliteTrails.push(trail);
                    earthGroup.add(trail.group); 
                }

                if (orbitsVisible) {
                    const orbitGroup = createOrbitPath(satData, color);
                    orbitPaths.push(orbitGroup);
                    earthGroup.add(orbitGroup);
                }
            });

            // Update Density Map visibility and counts
            if (densityMapMesh) {
                densityMapMesh.visible = densityMapVisible;
                if (densityMapVisible) {
                    updateDensityMap(displayedSatellitesData);
                }
            }

            populateSatelliteList(); 
            updateStats(); 
        }
        
        /**
         * Creates and adds a single orbit path for a given satellite.
         * @param {object} satData - The satellite data for which to create the orbit.
         * @param {number} color - The hexadecimal color for the orbit line.
         * @returns {THREE.Group} The Three.js group containing the orbit line.
         */
        function createOrbitPath(satData, color) {
            const orbitGroup = new THREE.Group();
            const orbitPoints = [];
            const segments = 128; 
            const radius = EARTH_RADIUS + (satData.altitude * SCALE_FACTOR); 

            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = radius * Math.cos(angle);
                const y = 0; 
                const z = radius * Math.sin(angle);
                orbitPoints.push(new THREE.Vector3(x, y, z));
            }
            const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);

            const orbitMaterial = new THREE.LineBasicMaterial({
                color: color, 
                transparent: true,
                opacity: 0.4 
            });
            const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);

            orbitLine.rotation.x = satData.inclination * Math.PI / 180; 
            orbitLine.rotation.y = Math.random() * Math.PI * 2; 

            orbitGroup.add(orbitLine);
            return orbitGroup; // Visibility controlled by orbitsVisible global toggle and updateDisplay
        }
        
        /**
         * Creates a single 3D satellite object, represented by a glowing dot.
         * @param {object} satData - The data object for the satellite.
         * @param {number} index - The index of the satellite in its respective data array.
         * @param {number} color - The hexadecimal color for the satellite.
         * @returns {object} An object containing the Three.js group for the satellite, its data, and meshes.
         */
        function createSatellite(satData, index, color) {
            const group = new THREE.Group(); 
            
            const dotGeometry = new THREE.SphereGeometry(1.5, 8, 6); 
            const dotMaterial = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true,
                opacity: 0.9
            });
            const dot = new THREE.Mesh(dotGeometry, dotMaterial);
            group.add(dot);
            
            const glowGeometry = new THREE.SphereGeometry(2.5, 8, 6); 
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color, 
                transparent: true,
                opacity: 0.15, 
                blending: THREE.AdditiveBlending 
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glow);
            
            const position = latLonToPosition(satData.latitude, satData.longitude, satData.altitude);
            group.position.copy(position);
            
            group.scale.setScalar(satelliteSize);
            // Visibility will be handled by updateDisplayFromControls based on its type and global toggles
            group.visible = true; 

            return {
                group: group, 
                data: satData, 
                dot: dot, 
                glow: glow, 
                index: index, 
                type: satData.type 
            };
        }
        
        /**
         * Creates a visual trail behind a satellite as it moves.
         * @param {object} satData - The satellite's data.
         * @param {number} color - The hexadecimal color for the trail.
         * @returns {object} An object containing the trail's Three.js group, points, and geometry.
         */
        function createSatelliteTrail(satData, color) {
            const group = new THREE.Group();
            const trailPoints = [];
            
            const currentPos = latLonToPosition(satData.latitude, satData.longitude, satData.altitude);
            for (let i = 0; i < TRAIL_LENGTH; i++) {
                trailPoints.push(currentPos.clone()); 
            }
            
            const trailGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = []; 
            const baseColor = new THREE.Color(color);

            for (let i = 0; i < trailPoints.length; i++) {
                const point = trailPoints[i];
                positions.push(point.x, point.y, point.z);
                const alpha = i / TRAIL_LENGTH; 
                colors.push(baseColor.r, baseColor.g, baseColor.b, alpha); 
            }
            
            trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            trailGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 4)); 
            
            const trailMaterial = new THREE.LineBasicMaterial({
                vertexColors: true, 
                transparent: true,
                opacity: 0.8 
            });
            
            const trailLine = new THREE.Line(trailGeometry, trailMaterial);
            group.add(trailLine);
            return {
                group: group, 
                points: trailPoints, 
                geometry: trailGeometry, 
                line: trailLine 
            };
        }
        
        /**
         * Populates the HTML sidebar list with satellite names.
         */
        function populateSatelliteList() {
            const listContent = document.getElementById('satelliteListContent');
            listContent.innerHTML = ''; 
            displayedSatellitesData.forEach((satData, index) => { 
                const item = document.createElement('div');
                item.className = 'satellite-item';
                item.dataset.index = index; 
                const statusDot = document.createElement('div');
                statusDot.className = `satellite-status-dot ${satData.type}`; // Use type for class
                const nameSpan = document.createElement('span');
                nameSpan.textContent = satData.name;
                item.appendChild(statusDot);
                item.appendChild(nameSpan);
                item.addEventListener('click', () => selectSatellite(index)); 
                listContent.appendChild(item);
            });
        }
        
        /**
         * Handles satellite selection: updates UI list, shows details, and highlights in 3D.
         * @param {number} index - The index of the selected satellite within `displayedSatellitesData`.
         */
        function selectSatellite(index) {
            document.querySelectorAll('.satellite-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            const selectedItem = document.querySelector(`[data-index="${index}"]`);
            if (selectedItem) {
                selectedItem.classList.add('selected');
            }
            
            const satData = displayedSatellitesData[index];
            selectedSatellite = allSatellites3D.find(s => s.data.id === satData.id); // Find the actual 3D object

            showSatelliteDetails(satData); 
            
            highlightSatellite(selectedSatellite); 
        }
        
        /**
         * Displays detailed information about a selected satellite in the UI panel.
         * @param {object} satData - The data of the satellite to display.
         */
        function showSatelliteDetails(satData) {
            const detailsContent = document.getElementById('satelliteDetailsContent');
            detailsContent.innerHTML = `
                <div class="detail-item">
                    <span>Name:</span>
                    <span class="detail-value">${satData.name}</span>
                </div>
                <div class="detail-item">
                    <span>Type:</span>
                    <span class="detail-value">${satData.type.replace('-', ' ').toUpperCase()}</span>
                </div>
                <div class="detail-item">
                    <span>Status:</span>
                    <span class="detail-value">${satData.status.toUpperCase()}</span>
                </div>
                <div class="detail-item">
                    <span>Altitude:</span>
                    <span class="detail-value">${satData.altitude.toFixed(1)} km</span>
                </div>
                <div class="detail-item">
                    <span>Inclination:</span>
                    <span class="detail-value">${satData.inclination.toFixed(1)}°</span>
                </div>
                <div class="detail-item">
                    <span>Velocity:</span>
                    <span class="detail-value">${satData.velocity.toFixed(2)} km/s</span>
                </div>
                <div class="detail-item">
                    <span>Latitude:</span>
                    <span class="detail-value">${satData.latitude.toFixed(2)}°</span>
                </div>
                <div class="detail-item">
                    <span>Longitude:</span>
                    <span class="detail-value">${satData.longitude.toFixed(2)}°</span>
                </div>
                ${satData.launchYear ? `<div class="detail-item">
                    <span>Launch Year:</span>
                    <span class="detail-value">${satData.launchYear}</span>
                </div>` : ''}
            `;
            
            document.getElementById('satelliteDetails').style.display = 'block'; 
        }
        
        /**
         * Visually highlights a specific satellite in the 3D scene and dims others.
         * @param {object} highlightedSat - The 3D satellite object to highlight.
         */
        function highlightSatellite(highlightedSat) {
            allSatellites3D.forEach((sat) => {
                if (sat === highlightedSat) {
                    sat.dot.material.emissive.setHex(0x444444); 
                    sat.glow.material.opacity = 0.4; 
                    sat.glow.material.color.setHex(STARLINK_COLOR); // Consistent highlight color
                } else {
                    let originalColor;
                    if (sat.type === 'starlink') originalColor = STARLINK_COLOR;
                    else if (sat.type === 'other-leo') originalColor = OTHER_LEO_COLOR;
                    else if (sat.type === 'debris') originalColor = DEBRIS_COLOR;
                    else if (sat.type === 'inactive') originalColor = INACTIVE_COLOR;

                    sat.dot.material.emissive.setHex(0x000000); 
                    sat.dot.material.color.setHex(originalColor); 
                    sat.glow.material.opacity = 0.15;
                    sat.glow.material.color.setHex(originalColor); 
                }
            });
        }
        
        /**
         * Handles mouse click events on the 3D canvas for satellite selection.
         */
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const clickableObjects = allSatellites3D.filter(s => s.group.visible).map(s => s.dot); // Only check visible satellites
            const intersects = raycaster.intersectObjects(clickableObjects);
            
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                const foundSat = allSatellites3D.find(s => s.dot === clickedObject);

                if (foundSat) {
                    const displayedIndex = displayedSatellitesData.findIndex(s => s.id === foundSat.data.id);
                    if (displayedIndex !== -1) {
                         selectSatellite(displayedIndex);
                    }
                }
            } else {
                if (selectedSatellite) {
                    selectedSatellite = null;
                    document.querySelectorAll('.satellite-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    document.getElementById('satelliteDetails').style.display = 'none'; 
                    allSatellites3D.forEach(sat => { 
                        let originalColor;
                        if (sat.type === 'starlink') originalColor = STARLINK_COLOR;
                        else if (sat.type === 'other-leo') originalColor = OTHER_LEO_COLOR;
                        else if (sat.type === 'debris') originalColor = DEBRIS_COLOR;
                        else if (sat.type === 'inactive') originalColor = INACTIVE_COLOR;
                        
                        sat.dot.material.emissive.setHex(0x000000);
                        sat.dot.material.color.setHex(originalColor);
                        sat.glow.material.opacity = 0.15;
                        sat.glow.material.color.setHex(originalColor);
                    });
                }
            }
        }
        
        /**
         * Updates the positions and fading of satellite trails in the 3D scene.
         */
        function updateTrails() {
            satelliteTrails.forEach((trail) => {
                // Find the corresponding 3D satellite object for this trail
                // Need to iterate through all satellites to find the one associated with this trail
                const sat3D = allSatellites3D.find(s => {
                    // Check if this trail is directly attached to this satellite's group
                    // This is a simplified check assuming 1:1 trail to satellite and no complex hierarchy
                    return s.group.children.includes(trail.group); 
                });

                if (!sat3D || !sat3D.group.visible || !trailsVisible) {
                    trail.group.visible = false; // Hide trail if satellite or trails are not visible
                    return;
                } else {
                    trail.group.visible = true;
                }
                
                const currentPos = sat3D.group.position.clone();
                
                trail.points.push(currentPos);
                if (trail.points.length > TRAIL_LENGTH) {
                    trail.points.shift();
                }
                
                const positions = [];
                const colors = []; 
                let baseColor;
                if (sat3D.type === 'starlink') baseColor = new THREE.Color(STARLINK_COLOR);
                else if (sat3D.type === 'other-leo') baseColor = new THREE.Color(OTHER_LEO_COLOR);
                else if (sat3D.type === 'debris') baseColor = new THREE.Color(DEBRIS_COLOR);
                else if (sat3D.type === 'inactive') baseColor = new THREE.Color(INACTIVE_COLOR);

                for (let i = 0; i < trail.points.length; i++) {
                    const point = trail.points[i];
                    positions.push(point.x, point.y, point.z);
                    const alpha = i / TRAIL_LENGTH; 
                    colors.push(baseColor.r, baseColor.g, baseColor.b, alpha); 
                }
                
                trail.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                trail.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 4)); 
                trail.geometry.attributes.position.needsUpdate = true; 
                trail.geometry.attributes.color.needsUpdate = true; 
            });
        }
        
        /**
         * Converts geographic coordinates (latitude, longitude, altitude) to a Three.js 3D Cartesian position.
         * @param {number} lat - Latitude in degrees.
         * @param {number} lon - Longitude in degrees.
         * @param {number} alt - Altitude in kilometers above Earth's surface.
         * @returns {THREE.Vector3} The 3D position vector in Three.js scene coordinates.
         */
        function latLonToPosition(lat, lon, alt) {
            const phi = (90 - lat) * Math.PI / 180; 
            const theta = (lon + 180) * Math.PI / 180; 
            
            const radius = EARTH_RADIUS + (alt * SCALE_FACTOR); 
            
            const x = -(radius * Math.sin(phi) * Math.cos(theta)); 
            const z = radius * Math.sin(phi) * Math.sin(theta);
            const y = radius * Math.cos(phi);
            
            return new THREE.Vector3(x, y, z);
        }
        
        /**
         * Sets up all UI control button click handlers and mouse/touch interactions for camera control.
         */
        function setupControls() {
            // New Toggle functions for different satellite types and density map
            document.getElementById('toggleStarlink').onclick = (event) => {
                starlinkVisible = !starlinkVisible;
                updateDisplayFromControls();
                event.target.classList.toggle('active', starlinkVisible);
            };
            document.getElementById('toggleOtherLeo').onclick = (event) => {
                otherLeoVisible = !otherLeoVisible;
                updateDisplayFromControls();
                event.target.classList.toggle('active', otherLeoVisible);
            };
            document.getElementById('toggleDebris').onclick = (event) => {
                debrisVisible = !debrisVisible;
                updateDisplayFromControls();
                event.target.classList.toggle('active', debrisVisible);
            };
            document.getElementById('toggleInactive').onclick = (event) => {
                inactiveVisible = !inactiveVisible;
                updateDisplayFromControls();
                event.target.classList.toggle('active', inactiveVisible);
            };
            document.getElementById('toggleDensityMap').onclick = (event) => {
                densityMapVisible = !densityMapVisible;
                if (densityMapMesh) {
                    densityMapMesh.visible = densityMapVisible;
                    if (densityMapVisible) {
                        updateDensityMap(displayedSatellitesData); // Update when shown
                    }
                }
                event.target.classList.toggle('active', densityMapVisible);
            };


            document.getElementById('toggleOrbits').onclick = (event) => {
                orbitsVisible = !orbitsVisible;
                updateDisplayFromControls(); 
                event.target.classList.toggle('active', orbitsVisible); 
            };
            
            document.getElementById('toggleLabels').onclick = (event) => {
                labelsVisible = !labelsVisible;
                const satelliteList = document.getElementById('satelliteList');
                satelliteList.style.display = labelsVisible ? 'block' : 'none';
                document.getElementById('satelliteDetails').style.display = 'none'; 
                
                selectedSatellite = null;
                document.querySelectorAll('.satellite-item').forEach(item => {
                    item.classList.remove('selected');
                });
                allSatellites3D.forEach(sat => { 
                    let originalColor;
                    if (sat.type === 'starlink') originalColor = STARLINK_COLOR;
                    else if (sat.type === 'other-leo') originalColor = OTHER_LEO_COLOR;
                    else if (sat.type === 'debris') originalColor = DEBRIS_COLOR;
                    else if (sat.type === 'inactive') originalColor = INACTIVE_COLOR;
                    
                    sat.dot.material.emissive.setHex(0x000000);
                    sat.dot.material.color.setHex(originalColor);
                    sat.glow.material.opacity = 0.15;
                    sat.glow.material.color.setHex(originalColor);
                });

                event.target.classList.toggle('active', labelsVisible); 
            };
            
            document.getElementById('toggleTrails').onclick = (event) => {
                trailsVisible = !trailsVisible;
                updateDisplayFromControls(); 
                event.target.classList.toggle('active', trailsVisible); 
            };
            
            renderer.domElement.addEventListener('click', onMouseClick);
            
            let mouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!mouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                earthGroup.rotation.y += deltaX * 0.005; 
                earthGroup.rotation.x += deltaY * 0.005; 
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('wheel', (event) => {
                event.preventDefault(); 
                const zoomSpeed = 0.001; 
                camera.position.z += event.deltaY * zoomSpeed * camera.position.z; 
                
                camera.position.z = Math.max(150, Math.min(camera.position.z, 2000));
                camera.lookAt(GLOBE_OFFSET_X, 0, 0); 
            });

            let touchStartX = 0;
            let touchStartY = 0;
            let lastTouchX = 0;
            let lastTouchY = 0;
            let isTouching = false;

            renderer.domElement.addEventListener('touchstart', (event) => {
                if (event.touches.length === 1) {
                    isTouching = true;
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                    lastTouchX = touchStartX;
                    lastTouchY = touchStartY;
                }
            });

            renderer.domElement.addEventListener('touchmove', (event) => {
                if (isTouching && event.touches.length === 1) {
                    const currentTouchX = event.touches[0].clientX;
                    const currentTouchY = event.touches[0].clientY;

                    const deltaX = currentTouchX - lastTouchX;
                    const deltaY = currentTouchY - lastTouchY;

                    earthGroup.rotation.y += deltaX * 0.005;
                    earthGroup.rotation.x += deltaY * 0.005;

                    lastTouchX = currentTouchX;
                    lastTouchY = currentTouchY;
                }
            });

            renderer.domElement.addEventListener('touchend', () => {
                isTouching = false;
            });
        }

        /**
         * Sets up the timeline slider functionality.
         */
        function setupTimelineSlider() {
            const slider = document.getElementById('timelineSlider');
            const yearDisplay = document.getElementById('yearDisplay');

            const currentYear = new Date().getFullYear();
            slider.max = currentYear;
            slider.value = currentYear; 
            yearDisplay.textContent = currentYear;

            slider.oninput = () => {
                const selectedYear = parseInt(slider.value);
                yearDisplay.textContent = selectedYear;
                updateDisplayFromControls(); // Trigger full display update
            };
        }

        /**
         * Sets up the percentage slider functionality.
         */
        function setupPercentageSlider() {
            const slider = document.getElementById('percentageSlider');
            const percentageDisplay = document.getElementById('percentageDisplay');

            slider.value = currentDisplayPercentage * 100;
            percentageDisplay.textContent = `${slider.value}%`;

            slider.oninput = () => {
                const selectedPercentage = parseInt(slider.value);
                currentDisplayPercentage = selectedPercentage / 100; 
                percentageDisplay.textContent = `${selectedPercentage}%`;
                updateDisplayFromControls(); // Trigger full display update
            };
        }
        
        /**
         * Sets the visual size of all satellites in the 3D scene.
         * @param {number} size - The new scaling factor for satellite meshes.
         * @param {HTMLElement} clickedButton - The button element that was clicked (for 'active' class).
         */
        function setSatelliteSize(size, clickedButton) {
            satelliteSize = size;
            allSatellites3D.forEach(sat => { 
                sat.group.scale.setScalar(size); 
            });
            
            document.querySelectorAll('#controls .control-group button').forEach(btn => {
                if (btn.onclick && btn.onclick.toString().includes('setSatelliteSize')) { 
                    btn.classList.remove('active');
                }
            });
            clickedButton.classList.add('active');
        }
        
        /**
         * Adjusts the camera to a predefined view that focuses on the satellite constellation.
         */
        function focusOnConstellation() {
            camera.position.set(400, 300, 400); 
            camera.lookAt(GLOBE_OFFSET_X, 0, 0); 
        }
        
        /**
         * Resets the camera view and Earth's rotation to their initial states.
         */
        function resetView() {
            camera.position.set(0, 0, 300); 
            camera.lookAt(GLOBE_OFFSET_X, 0, 0); 
            if (earthGroup) {
                earthGroup.rotation.set(0, 0, 0); 
                earthGroup.position.x = GLOBE_OFFSET_X; 
            }
        }
        
        /**
         * Updates the live statistics displayed in the UI panels.
         */
        function updateStats() {
            const starlinks = displayedSatellitesData.filter(s => s.type === 'starlink');
            const otherLeos = displayedSatellitesData.filter(s => s.type === 'other-leo');
            const debris = displayedSatellitesData.filter(s => s.type === 'debris');
            const inactives = displayedSatellitesData.filter(s => s.type === 'inactive');

            const totalActive = starlinks.length + otherLeos.length + debris.length + inactives.length;
            const totalAltitude = displayedSatellitesData.reduce((sum, sat) => sum + sat.altitude, 0);
            const avgAlt = displayedSatellitesData.length > 0 ? totalAltitude / displayedSatellitesData.length : 0;
            
            // Coverage calculation remains a simplified approximation
            const coverage = Math.min(100, (totalActive / 10000) * 100); // Assuming higher total target for all LEO

            document.getElementById('totalDisplayedSats').textContent = totalActive;
            document.getElementById('starlinkDisplayedSats').textContent = starlinks.length;
            document.getElementById('otherLeoDisplayedSats').textContent = otherLeos.length;
            document.getElementById('debrisDisplayedSats').textContent = debris.length;
            document.getElementById('inactiveDisplayedSats').textContent = inactives.length;
            document.getElementById('avgAlt').textContent = Math.round(avgAlt) + ' km';
            document.getElementById('coverage').textContent = Math.round(coverage) + '%';
        }

        /**
         * Creates the conceptual density map grid.
         * The cells will be updated in `updateDensityMap`.
         */
        function createDensityMap() {
            const gridCells = [];
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, // Base color for density
                transparent: true, 
                opacity: 0, // Initially invisible
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending // For glow effect
            });
            const cellHeight = (LEO_ALT_MAX - LEO_ALT_MIN) * SCALE_FACTOR / DENSITY_ALTITUDE_LAYERS;

            for (let latIdx = 0; latIdx < DENSITY_GRID_RESOLUTION; latIdx++) {
                for (let lonIdx = 0; lonIdx < DENSITY_GRID_RESOLUTION * 2; lonIdx++) { // *2 for longitude (0-360)
                    for (let altIdx = 0; altIdx < DENSITY_ALTITUDE_LAYERS; altIdx++) {
                        const geometry = new THREE.BoxGeometry(
                            (Math.PI * EARTH_RADIUS * 2 / (DENSITY_GRID_RESOLUTION * 2)), // Approx width at equator
                            (Math.PI * EARTH_RADIUS * 2 / DENSITY_GRID_RESOLUTION), // Approx height
                            cellHeight // Altitude segment thickness
                        );
                        const cellMesh = new THREE.Mesh(geometry, material.clone()); // Clone material for individual opacity
                        
                        // Calculate center of cell in lat/lon/alt
                        const lat = (latIdx / DENSITY_GRID_RESOLUTION) * 180 - 90 + (90/DENSITY_GRID_RESOLUTION);
                        const lon = (lonIdx / (DENSITY_GRID_RESOLUTION * 2)) * 360 - 180 + (180/(DENSITY_GRID_RESOLUTION*2));
                        const alt = LEO_ALT_MIN + (altIdx * (LEO_ALT_MAX - LEO_ALT_MIN) / DENSITY_ALTITUDE_LAYERS) + ((LEO_ALT_MAX - LEO_ALT_MIN) / (DENSITY_ALTITUDE_LAYERS * 2));
                        
                        const position = latLonToPosition(lat, lon, alt);
                        cellMesh.position.copy(position);
                        cellMesh.lookAt(earthGroup.position); // Point boxes towards center
                        
                        gridCells.push({ mesh: cellMesh, count: 0, latRange: [lat - 90/DENSITY_GRID_RESOLUTION, lat + 90/DENSITY_GRID_RESOLUTION], lonRange: [lon - 180/(DENSITY_GRID_RESOLUTION*2), lon + 180/(DENSITY_GRID_RESOLUTION*2)], altRange: [alt - (cellHeight/SCALE_FACTOR)/2, alt + (cellHeight/SCALE_FACTOR)/2] });
                        earthGroup.add(cellMesh);
                    }
                }
            }
            densityMapMesh = new THREE.Group(); // Use a group to contain all cells
            gridCells.forEach(cell => densityMapMesh.add(cell.mesh));
            earthGroup.add(densityMapMesh); // Add the group to earthGroup
            densityMapMesh.visible = densityMapVisible; // Initial visibility
            densityMapMesh.userData.gridCells = gridCells; // Store grid cells for easy access
        }

        /**
         * Updates the conceptual density map based on current satellite positions.
         * @param {Array<Object>} satellitesData - Array of satellite data objects currently displayed.
         */
        function updateDensityMap(satellitesData) {
            if (!densityMapMesh || !densityMapVisible) return;

            // Reset counts for all cells
            densityMapMesh.userData.gridCells.forEach(cell => cell.count = 0);

            // Calculate density for each cell
            satellitesData.forEach(sat => {
                const satLat = sat.latitude;
                const satLon = sat.longitude;
                const satAlt = sat.altitude;

                densityMapMesh.userData.gridCells.forEach(cell => {
                    const [minLat, maxLat] = cell.latRange;
                    const [minLon, maxLon] = cell.lonRange;
                    const [minAlt, maxAlt] = cell.altRange;

                    // Simple check if satellite is within cell's lat/lon/alt bounds
                    if (satLat >= minLat && satLat < maxLat &&
                        satAlt >= minAlt && satAlt < maxAlt) {
                        // Handle longitude wrap-around (e.g., -180 to 180)
                        if (minLon < maxLon) {
                            if (satLon >= minLon && satLon < maxLon) {
                                cell.count++;
                            }
                        } else { // Crosses the anti-meridian
                            if (satLon >= minLon || satLon < maxLon) {
                                cell.count++;
                            }
                        }
                    }
                });
            });

            // Update cell colors/opacity based on count
            const maxCount = Math.max(...densityMapMesh.userData.gridCells.map(cell => cell.count));
            densityMapMesh.userData.gridCells.forEach(cell => {
                const density = cell.count;
                let opacity = 0;
                let color = new THREE.Color(0x00ff00); // Green base for heatmap
                
                if (maxCount > 0) {
                    opacity = density / maxCount * 0.4; // Max opacity 40%
                    // Interpolate color from green to yellow to red
                    if (opacity > 0) {
                        if (opacity < 0.2) { // Green for low density
                            color.setHSL(0.33, 1, 0.5); // Green
                        } else if (opacity < 0.3) { // Yellow for medium density
                            color.setHSL(0.16, 1, 0.5); // Yellow
                        } else { // Red for high density
                            color.setHSL(0.0, 1, 0.5); // Red
                        }
                    }
                }
                cell.mesh.material.color.set(color);
                cell.mesh.material.opacity = opacity;
            });
        }
        
        /**
         * The main animation loop for the 3D scene.
         */
        function animate() {
            if (!isAnimating) return; 
            requestAnimationFrame(animate); 

            if (earthGroup) {
                earthGroup.rotation.y += 0.0005; 
            }
            
            const now = new Date();
            // Update positions only for real satellites with TLEs
            allSatellites3D.forEach((sat3D) => { 
                if (sat3D.data.satrec) { // Only propagate real satellites
                    const satData = sat3D.data;
                    const pos = getSatPosition(satData.satrec, now);
                    
                    if (pos) { 
                        const position = latLonToPosition(pos.latitude, pos.longitude, pos.altitude);
                        sat3D.group.position.copy(position);

                        // Update data for details panel
                        satData.latitude = pos.latitude;
                        satData.longitude = pos.longitude;
                        satData.altitude = pos.altitude;
                        
                        if (selectedSatellite && selectedSatellite.data.id === satData.id) {
                            showSatelliteDetails(satData);
                        }
                    }
                }
            });
            
            updateTrails(); 
            if (densityMapVisible) {
                updateDensityMap(displayedSatellitesData); // Update heatmap with current positions
            }
            renderer.render(scene, camera); 
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        window.onload = init;
    </script>
</body>
</html>
